use std::str::FromStr;
use std::rc::Rc;
use lalrpop_util::ParseError;
use midnight_security_rules_sdk::ast::node::{ Type, Location };
use midnight_security_rules_sdk::ast::literal::{ Literal, Nat, Bool, Version, Str };
use midnight_security_rules_sdk::ast::directive::{ Directive, Pragma, PragmaOperator};
use midnight_security_rules_sdk::ast::declaration::{ Declaration, Import, Export, Ledger };
use midnight_security_rules_sdk::ast::expression::{ Expression, Identifier, BinaryExpressionOperator };
use midnight_security_rules_sdk::ast::program::CompactNode;

grammar;

match {
    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
    _,
} else {
    "true" => TRUE,
    "false" => FALSE,
    r#""[^\\"\n\r]*(\\[tnfbrx'"\\0-9][^\\"\n\r]*)*""# => STR,
    r"[a-zA-Z_][a-zA-Z0-9_]*" => ID,
}

pub Term: CompactNode = {
    <d:Directive> => CompactNode::Directive(d),
    <d:Declaration> => CompactNode::Declaration(d),
    <e:Expression> => CompactNode::Expression(e),
}

pub Directive: Directive = {
    <p:Pragma> => Directive::Pragma(p),
}

pub Declaration: Declaration = {
    <i:Import> => Declaration::Import(i),
    <e:Export> => Declaration::Export(e),
    <l:Ledger> => Declaration::Ledger(l),
}

pub Expression : Expression = {
    <i:Identifier> => Expression::Identifier(i),
    <l:Literal> => Expression::Literal(l),
}

pub Literal : Literal = {
    <v:Version> => Literal::Version(v),
    <n:Nat> => Literal::Nat(n),
    <b:Bool> => Literal::Bool(b),
    <s:Str> => Literal::Str(s),
}

Type: Type = {
    "Boolean" => Type::Bool,
    "Field" => Type::Field,
    "Uint" "<" <s:Nat> ">" => Type::Uint(s, None),
    "Uint" "<" <s:Nat> ".." <e:Nat> ">" => Type::Uint(s, Some(e)),
    "Vector" "<" <s:Nat> "," <t:Type> ">" => Type::Vector(s, Box::new(t)),
    "Bytes" "<" <s:Nat> ">" => Type::Bytes(s),
    "Opaque" "<" <s:Str> ">" => Type::Opaque(s),
    "[" <i:Identifier> "]" => Type::Ref(i, None),
    "[" <i:Identifier> <v:CBIndentifiersList> "]" => Type::Ref(i, Some(v)),
    "[" <CommaTwo<Type>> "]" => Type::Sum(<>),
}

Nat : Rc<Nat> = {
    <start: @L> <n:r"0|[1-9]\d*"> <end: @R> => Rc::new(Nat 
    {
        id: 0,
        location: Location::new(start, end),
        value: u64::from_str(n).unwrap()
    }),
}

Bool : Rc<Bool> = {
    <start: @L> <b:TRUE> <end: @R> => Rc::new(Bool {
        id: 0,
        location: Location::new(start, end),
        value: true
    }),
    <start: @L> <b:FALSE> <end: @R> => Rc::new(Bool {
        id: 0,
        location: Location::new(start, end),
        value: false
    })
}

Version : Rc<Version> = {
    <start: @L> <major:Nat> "." <minor:Nat> "." <bugfix:Nat> <end: @R> => Rc::new(Version {
        id : 0,
        location: Location::new(start, end),
        major,
        minor,
        bugfix: Some(bugfix)
    }),
    <start: @L> <major:Nat> "." <minor:Nat> <end: @R> => Rc::new(Version {
        id : 0,
        location: Location::new(start, end),
        major, 
        minor,
        bugfix: None
    })
}

Str : Rc<Str> = {
    <start: @L> <s:STR> <end: @R>  => Rc::new(Str {
        id: 0,
        location: Location::new(start, end),
        value: String::from(s)
    })
}

Identifier: Rc<Identifier> = {
    <start: @L> <i: ID> <end: @R> =>? {
         if i.to_lowercase() == "true" || i.to_lowercase() == "false" {
             Err(ParseError::User { error: "Invalid identifier" })
         } else {
             Ok(Rc::new(Identifier {
                 id: 0,
                 location: Location::new(start, end),
                 name: i.to_owned(),
             }))
         }
    }
}

CBIndentifiersList: Vec<Rc<Identifier>> = {
    "{" "}" => Vec::new(),
    "{" <i:Identifier> "}" => vec![i],
    "{" <CommaTwo<Identifier>> "}" => <>
}

BinaryExpressionOperator : BinaryExpressionOperator = {
    "+" => BinaryExpressionOperator::Add,
    "-" => BinaryExpressionOperator::Sub,
    "*" => BinaryExpressionOperator::Mul,
    "/" => BinaryExpressionOperator::Div,
    "%" => BinaryExpressionOperator::Mod,
    "**" => BinaryExpressionOperator::Pow,
    "==" => BinaryExpressionOperator::Eq,
    "!=" => BinaryExpressionOperator::Ne,
    "<" => BinaryExpressionOperator::Lt,
    "=<" => BinaryExpressionOperator::Le,
    ">" => BinaryExpressionOperator::Gt,
    ">=" => BinaryExpressionOperator::Ge,
    "&&" => BinaryExpressionOperator::And,
    "||" => BinaryExpressionOperator::Or,
    "&" => BinaryExpressionOperator::BitAnd,
    "|" => BinaryExpressionOperator::BitOr,
    "^" => BinaryExpressionOperator::BitXor,
    "!" => BinaryExpressionOperator::BitNot,
    "<<" => BinaryExpressionOperator::Shl,
    ">>" => BinaryExpressionOperator::Shr,
}

PragmaOperator: PragmaOperator = {
    "=" => PragmaOperator::Eq,
    ">" => PragmaOperator::Gt,
    ">=" => PragmaOperator::Ge,
}

Pragma : Rc<Pragma> = {
    <start: @L> "pragma" <value:Identifier> <op:PragmaOperator> <version:Version> ";" <end: @R> => Rc::new(Pragma {
        id: 0,
        location: Location::new(start, end),
        value: value.clone(),
        version: version.clone(),
        operator: op.clone()
    })
}

Import : Rc<Import> = {
    <start: @L> "import" <value:Identifier> ";" <end: @R> => Rc::new(Import {
        id: 0,
        location: Location::new(start, end),
        value: value.clone()
    }),
    <start: @L> "import" <path:STR> ";" <end: @R> => Rc::new(Import {
        id: 0,
        location: Location::new(start, end),
        value: Rc::new(Identifier {
                 id: 0,
                 location: Location::new(start, end),
                 name: path.to_owned(),
             })
    })
}

Export: Rc<Export> = {
    <start: @L> "export" <v:CBIndentifiersList> <t:";"?>  <end: @R> => Rc::new(Export {
        id: 0,
        location: Location::new(start, end),
        values: v.clone()
    }),
}

Ledger: Rc<Ledger> = {
    <start: @L> "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: false,
        is_sealed: false,
        name: i.clone(),
        ty: t
    }),
    <start: @L> "export" "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: true,
        is_sealed: false,
        name: i.clone(),
        ty: t
    }),
    <start: @L> "sealed" "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: false,
        is_sealed: true,
        name: i.clone(),
        ty: t
    }),
    <start: @L> "export" "sealed" "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: true,
        is_sealed: true,
        name: i.clone(),
        ty: t
    }),
}

CommaTwo<T>: Vec<T> = {
    <e:T> <v:("," <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};
