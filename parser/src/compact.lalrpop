use std::str::FromStr;
use std::rc::Rc;
use midnight_security_rules_sdk::ast::node::{ Type, Location };
use midnight_security_rules_sdk::ast::literal::{ Literal, Nat, Bool, Version, Str };
use midnight_security_rules_sdk::ast::directive::{ Directive, Pragma, PragmaOperator };
use midnight_security_rules_sdk::ast::statement::{ Statement, Assign, AssignOperator, Block, If, Return };
use midnight_security_rules_sdk::ast::declaration::{ Argument, StructPatternItem, Declaration, Import, Export, Ledger, Pattern };
use midnight_security_rules_sdk::ast::expression::{ Expression, Sequence, Identifier, BinaryExpressionOperator };
use midnight_security_rules_sdk::ast::program::CompactNode;

grammar;

match {
    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
    _,
} else {
    "true" => TRUE,
    "false" => FALSE,
    r#""[^\\"\n\r]*(\\[tnfbrx'"\\0-9][^\\"\n\r]*)*""# => STR,
    r"[a-zA-Z_][a-zA-Z0-9_]*" => ID,
}

pub Term: CompactNode = {
    <d:Directive> => CompactNode::Directive(d),
    <d:Declaration> => CompactNode::Declaration(d),
    <s:Statement> => CompactNode::Statement(s)
}

pub Directive: Directive = {
    <p:Pragma> => Directive::Pragma(p),
}

pub Declaration: Declaration = {
    <i:Import> => Declaration::Import(i),
    <e:Export> => Declaration::Export(e),
    <l:Ledger> => Declaration::Ledger(l),
}

pub Statement: Statement = {
    <start: @L> <e1:Expression> "=" <e2:Expression> ";" <end: @R> => Statement::Assign(Rc::new(Assign {
        id: 0,
        location: Location::new(start, end),
        target: e1,
        value: e2,
        operator: AssignOperator::Simple
    })),
    <start: @L> <e1:Expression> "+=" <e2:Expression> ";" <end: @R> => Statement::Assign(Rc::new(Assign {
        id: 0,
        location: Location::new(start, end),
        target: e1,
        value: e2,
        operator: AssignOperator::Add
    })),
    <start: @L> <e1:Expression> "-=" <e2:Expression> ";" <end: @R> => Statement::Assign(Rc::new(Assign {
        id: 0,
        location: Location::new(start, end),
        target: e1,
        value: e2,
        operator: AssignOperator::Sub
    })),
    <start: @L> "return" ";" <end: @R> => Statement::Return(Rc::new(Return {
        id: 0,
        location: Location::new(start, end),
        value: None
    })),
     <start: @L> "return" <e:Expression> ";" <end: @R> => Statement::Return(Rc::new(Return {
        id: 0,
        location: Location::new(start, end),
        value: Some(e)
    })),
    <start: @L> "return" <s:Sequence> ";" <end: @R> => Statement::Return(Rc::new(Return {
        id: 0,
        location: Location::new(start, end),
        value: Some(Expression::Sequence(s))
    })),
    <start: @L>  <s:Sequence> ";"  <end: @R> => {
        Statement::ExpressionSequence(s)
    },
    <start: @L> "if" "(" <e:Expression> ")" <b:Block> <end: @R> => {
        Statement::If(Rc::new(If {
            id: 0,
            location: Location::new(start, end),
            condition: e,
            then_branch: b,
            else_branch: None
        }))
    },
    <start: @L> "if" "(" <e:Expression> ")" <b1:Block> "else" <b2:Block> <end: @R> => {
        Statement::If(Rc::new(If {
            id: 0,
            location: Location::new(start, end),
            condition: e,
            then_branch: b1,
            else_branch: Some(b2)
        }))
    },
    <b:Block> => Statement::Block(b),
}

Block: Rc<Block> = {
    <start: @L> "{" <statements:Statement*> "}" <end: @R> => Rc::new(Block {
        id: 0,
        location: Location::new(start, end),
        statements
    }),
}

pub Expression : Expression = {
    <i:Identifier> => Expression::Identifier(i),
    <l:Literal> => Expression::Literal(l),
}

pub Literal : Literal = {
    <v:Version> => Literal::Version(v),
    <n:Nat> => Literal::Nat(n),
    <b:Bool> => Literal::Bool(b),
    <s:Str> => Literal::Str(s),
}

Type: Type = {
    "Boolean" => Type::Bool,
    "Field" => Type::Field,
    "Uint" "<" <s:Nat> ">" => Type::Uint(s, None),
    "Uint" "<" <s:Nat> ".." <e:Nat> ">" => Type::Uint(s, Some(e)),
    "Vector" "<" <s:Nat> "," <t:Type> ">" => Type::Vector(s, Box::new(t)),
    "Bytes" "<" <s:Nat> ">" => Type::Bytes(s),
    "Opaque" "<" <s:Str> ">" => Type::Opaque(s),
    "[" <i:Identifier> "]" => Type::Ref(i, None),
    "[" <i:Identifier> <v:CBIndentifiersList> "]" => Type::Ref(i, Some(v)),
    "[" <CommaTwo<Type>> "]" => Type::Sum(<>),
}

Nat : Rc<Nat> = {
    <start: @L> <n:r"0|[1-9]\d*"> <end: @R> => Rc::new(Nat 
    {
        id: 0,
        location: Location::new(start, end),
        value: u64::from_str(n).unwrap()
    }),
}

Bool : Rc<Bool> = {
    <start: @L> <b:TRUE> <end: @R> => Rc::new(Bool {
        id: 0,
        location: Location::new(start, end),
        value: true
    }),
    <start: @L> <b:FALSE> <end: @R> => Rc::new(Bool {
        id: 0,
        location: Location::new(start, end),
        value: false
    })
}

Version : Rc<Version> = {
    <start: @L> <major:Nat> "." <minor:Nat> "." <bugfix:Nat> <end: @R> => Rc::new(Version {
        id : 0,
        location: Location::new(start, end),
        major,
        minor,
        bugfix: Some(bugfix)
    }),
    <start: @L> <major:Nat> "." <minor:Nat> <end: @R> => Rc::new(Version {
        id : 0,
        location: Location::new(start, end),
        major, 
        minor,
        bugfix: None
    })
}

Str : Rc<Str> = {
    <start: @L> <s:STR> <end: @R>  => Rc::new(Str {
        id: 0,
        location: Location::new(start, end),
        value: String::from(s)
    })
}

Identifier: Rc<Identifier> = {
    <start: @L> <i: ID> <end: @R> => {
        Rc::new(Identifier {
            id: 0,
            location: Location::new(start, end),
            name: i.to_owned(),
        })
    }
}

Sequence: Rc<Sequence> = {
    <CommaTwo<Expression>> => {
        let expressions = <>;
        Rc::new(Sequence {
            id: 0,
            location: Location::new(
                expressions.first().unwrap().location().start,
                expressions.last().unwrap().location().end
            ),
            expressions
        })
    }
}

CBIndentifiersList: Vec<Rc<Identifier>> = {
    "{" "}" => Vec::new(),
    "{" <i:Identifier> "}" => vec![i],
    "{" <CommaTwo<Identifier>> "}" => <>
}

BinaryExpressionOperator : BinaryExpressionOperator = {
    "+" => BinaryExpressionOperator::Add,
    "-" => BinaryExpressionOperator::Sub,
    "*" => BinaryExpressionOperator::Mul,
    "/" => BinaryExpressionOperator::Div,
    "%" => BinaryExpressionOperator::Mod,
    "**" => BinaryExpressionOperator::Pow,
    "==" => BinaryExpressionOperator::Eq,
    "!=" => BinaryExpressionOperator::Ne,
    "<" => BinaryExpressionOperator::Lt,
    "=<" => BinaryExpressionOperator::Le,
    ">" => BinaryExpressionOperator::Gt,
    ">=" => BinaryExpressionOperator::Ge,
    "&&" => BinaryExpressionOperator::And,
    "||" => BinaryExpressionOperator::Or,
    "&" => BinaryExpressionOperator::BitAnd,
    "|" => BinaryExpressionOperator::BitOr,
    "^" => BinaryExpressionOperator::BitXor,
    "!" => BinaryExpressionOperator::BitNot,
    "<<" => BinaryExpressionOperator::Shl,
    ">>" => BinaryExpressionOperator::Shr,
}

PragmaOperator: PragmaOperator = {
    "=" => PragmaOperator::Eq,
    ">" => PragmaOperator::Gt,
    ">=" => PragmaOperator::Ge,
}

Pragma : Rc<Pragma> = {
    <start: @L> "pragma" <value:Identifier> <op:PragmaOperator> <version:Version> ";" <end: @R> => Rc::new(Pragma {
        id: 0,
        location: Location::new(start, end),
        value: value.clone(),
        version: version.clone(),
        operator: op.clone()
    })
}

Import : Rc<Import> = {
    <start: @L> "import" <value:Identifier> ";" <end: @R> => Rc::new(Import {
        id: 0,
        location: Location::new(start, end),
        value: value.clone()
    }),
    <start: @L> "import" <path:STR> ";" <end: @R> => Rc::new(Import {
        id: 0,
        location: Location::new(start, end),
        value: Rc::new(Identifier {
                 id: 0,
                 location: Location::new(start, end),
                 name: path.to_owned(),
             })
    })
}

Export: Rc<Export> = {
    <start: @L> "export" <v:CBIndentifiersList> <t:";"?>  <end: @R> => Rc::new(Export {
        id: 0,
        location: Location::new(start, end),
        values: v.clone()
    }),
}

Ledger: Rc<Ledger> = {
    <start: @L> "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: false,
        is_sealed: false,
        name: i.clone(),
        ty: t
    }),
    <start: @L> "export" "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: true,
        is_sealed: false,
        name: i.clone(),
        ty: t
    }),
    <start: @L> "sealed" "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: false,
        is_sealed: true,
        name: i.clone(),
        ty: t
    }),
    <start: @L> "export" "sealed" "ledger" <i:Identifier> ":" <t:Type> ";" <end: @R> => Rc::new(Ledger {
        id: 0,
        location: Location::new(start, end),
        is_exported: true,
        is_sealed: true,
        name: i.clone(),
        ty: t
    }),
}

StructPatternItem : Rc<StructPatternItem> = {
    <start: @L> <i:Identifier> <end: @R> => Rc::new(StructPatternItem {
        id: 0,
        location: Location::new(start, end),
        name: i,
        pattern: None
    }),
    <start: @L> <i:Identifier> <p:Pattern> <end: @R> => Rc::new(StructPatternItem {
        id: 0,
        location: Location::new(start, end),
        name: i,
        pattern: Some(p)
    }),
}

Pattern: Rc<Pattern> = {
    <start: @L> <i:Identifier> <end: @R> => Rc::new(Pattern::Identifier(i)),
    "[" <start: @L> <p:Pattern> <end: @R> "]" => Rc::new(Pattern::Tuple(p)),
    "{" <start: @L> <sp:StructPatternItem> <end: @R> "}" => Rc::new(Pattern::Struct(sp))
}

Argument : Rc<Argument> = {
    <start: @L> <p:Pattern> <t:Type> <end: @R> => Rc::new(Argument {
        id: 0,
        location: Location::new(start, end),
        pattern: p,
        ty: t
    })
}

Arguments: Vec<Rc<Argument>> = {
    "(" ")" => Vec::new(),
    "(" <CommaTwo<Argument>> ")" => <>
}

CommaTwo<T>: Vec<T> = {
    <e:T> <v:("," <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};
